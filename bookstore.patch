diff --git a/README.md b/README.md
index eb50da6..781f887 100644
--- a/README.md
+++ b/README.md
@@ -23,25 +23,25 @@ Play will start up on the HTTP port at http://localhost:9000/.   You don't need
 If you call the same URL from the command line, you’ll see JSON. Using httpie, we can execute the command:
 
 ```
-http --verbose http://localhost:9000/v1/posts
+http --verbose http://localhost:9000/v1/books
 ```
 
 and get back:
 
 ```
-GET /v1/posts HTTP/1.1
+GET /v1/books HTTP/1.1
 ```
 
 Likewise, you can also send a POST directly as JSON:
 
 ```
-http --verbose POST http://localhost:9000/v1/posts title="hello" body="world"
+http --verbose POST http://localhost:9000/v1/books title="hello" body="world"
 ```
 
 and get:
 
 ```
-POST /v1/posts HTTP/1.1
+POST /v1/books HTTP/1.1
 ```
 
 ### Load Testing
diff --git a/app/Module.scala b/app/Module.scala
index 7da2ce9..ed6b814 100644
--- a/app/Module.scala
+++ b/app/Module.scala
@@ -3,7 +3,7 @@ import javax.inject._
 import com.google.inject.AbstractModule
 import net.codingwell.scalaguice.ScalaModule
 import play.api.{Configuration, Environment}
-import v1.post._
+import v1.book._
 
 /**
   * Sets up custom components for Play.
@@ -15,6 +15,6 @@ class Module(environment: Environment, configuration: Configuration)
     with ScalaModule {
 
   override def configure() = {
-    bind[PostRepository].to[PostRepositoryImpl].in[Singleton]
+    bind[BookRepository].to[BookRepositoryImpl].in[Singleton]
   }
 }
diff --git a/app/RequestHandler.scala b/app/RequestHandler.scala
index 8bcbab0..1687295 100644
--- a/app/RequestHandler.scala
+++ b/app/RequestHandler.scala
@@ -31,7 +31,7 @@ class RequestHandler @Inject()(router: Router,
 
   private def isREST(request: RequestHeader) = {
     request.uri match {
-      case uri: String if uri.contains("post") => true
+      case uri: String if uri.contains("book") => true
       case _ => false
     }
   }
diff --git a/app/v1/book/BookAction.scala b/app/v1/book/BookAction.scala
new file mode 100644
index 0000000..8c24976
--- /dev/null
+++ b/app/v1/book/BookAction.scala
@@ -0,0 +1,54 @@
+package v1.book
+
+import javax.inject.Inject
+
+import play.api.http.HttpVerbs
+import play.api.i18n.{Messages, MessagesApi}
+import play.api.mvc._
+
+import scala.concurrent.{ExecutionContext, Future}
+
+/**
+  * A wrapped request for book resources.
+  *
+  * This is commonly used to hold request-specific information like
+  * security credentials, and useful shortcut methods.
+  */
+class BookRequest[A](request: Request[A], val messages: Messages)
+    extends WrappedRequest(request)
+
+/**
+  * The default action for the Book resource.
+  *
+  * This is the place to put logging, metrics, to augment
+  * the request with contextual data, and manipulate the
+  * result.
+  */
+class BookAction @Inject()(messagesApi: MessagesApi)(
+    implicit ec: ExecutionContext)
+    extends ActionBuilder[BookRequest]
+    with HttpVerbs {
+
+  type BookRequestBlock[A] = BookRequest[A] => Future[Result]
+
+  private val logger = org.slf4j.LoggerFactory.getLogger(this.getClass)
+
+  override def invokeBlock[A](request: Request[A],
+                              block: BookRequestBlock[A]): Future[Result] = {
+    if (logger.isTraceEnabled()) {
+      logger.trace(s"invokeBlock: request = $request")
+    }
+
+    val messages = messagesApi.preferred(request)
+    val future = block(new BookRequest(request, messages))
+
+    future.map { result =>
+      request.method match {
+        case GET | HEAD =>
+          result.withHeaders("Cache-Control" -> s"max-age: 100")
+        case other =>
+          result
+      }
+    }
+  }
+}
diff --git a/app/v1/book/BookController.scala b/app/v1/book/BookController.scala
new file mode 100644
index 0000000..527768a
--- /dev/null
+++ b/app/v1/book/BookController.scala
@@ -0,0 +1,68 @@
+package v1.book
+
+import javax.inject.Inject
+
+import play.api.data.Form
+import play.api.libs.json.Json
+import play.api.mvc._
+
+import scala.concurrent.{ExecutionContext, Future}
+
+case class BookFormInput(title: String, body: String)
+
+/**
+  * Takes HTTP requests and produces JSON.
+  */
+class BookController @Inject()(
+                                action: BookAction,
+                                handler: BookResourceHandler)(implicit ec: ExecutionContext)
+    extends Controller {
+
+  private val form: Form[BookFormInput] = {
+    import play.api.data.Forms._
+
+    Form(
+      mapping(
+        "title" -> nonEmptyText,
+        "body" -> text
+      )(BookFormInput.apply)(BookFormInput.unapply)
+    )
+  }
+
+  def index: Action[AnyContent] = {
+    action.async { implicit request =>
+      handler.find.map { book =>
+        Ok(Json.toJson(book))
+      }
+    }
+  }
+
+  def process: Action[AnyContent] = {
+    action.async { implicit request =>
+      processJsonBook()
+    }
+  }
+
+  def show(id: String): Action[AnyContent] = {
+    action.async { implicit request =>
+      handler.lookup(id).map { book =>
+        Ok(Json.toJson(book))
+      }
+    }
+  }
+
+  private def processJsonBook[A]()(
+      implicit request: BookRequest[A]): Future[Result] = {
+    def failure(badForm: Form[BookFormInput]) = {
+      Future.successful(BadRequest(badForm.errorsAsJson))
+    }
+
+    def success(input: BookFormInput) = {
+      handler.create(input).map { book =>
+        Created(Json.toJson(book)).withHeaders(LOCATION -> book.link)
+      }
+    }
+
+    form.bindFromRequest().fold(failure, success)
+  }
+}
diff --git a/app/v1/book/BookRepository.scala b/app/v1/book/BookRepository.scala
new file mode 100644
index 0000000..42b3002
--- /dev/null
+++ b/app/v1/book/BookRepository.scala
@@ -0,0 +1,68 @@
+package v1.book
+
+import javax.inject.{Inject, Singleton}
+
+import scala.concurrent.Future
+
+final case class BookData(id: BookId, title: String, body: String)
+
+class BookId private(val underlying: Int) extends AnyVal {
+  override def toString: String = underlying.toString
+}
+
+object BookId {
+  def apply(raw: String): BookId = {
+    require(raw != null)
+    new BookId(Integer.parseInt(raw))
+  }
+}
+
+/**
+  * A pure non-blocking interface for the BookRepository.
+  */
+trait BookRepository {
+  def create(data: BookData): Future[BookId]
+
+  def list(): Future[Iterable[BookData]]
+
+  def get(id: BookId): Future[Option[BookData]]
+}
+
+/**
+  * A trivial implementation for the Book Repository.
+  */
+@Singleton
+class BookRepositoryImpl @Inject() extends BookRepository {
+
+  private val logger = org.slf4j.LoggerFactory.getLogger(this.getClass)
+
+  private val bookList = List(
+    BookData(BookId("1"), "title 1", "blog book 1"),
+    BookData(BookId("2"), "title 2", "blog book 2"),
+    BookData(BookId("3"), "title 3", "blog book 3"),
+    BookData(BookId("4"), "title 4", "blog book 4"),
+    BookData(BookId("5"), "title 5", "blog book 5")
+  )
+
+  override def list(): Future[Iterable[BookData]] = {
+    Future.successful {
+      logger.trace(s"list: ")
+      bookList
+    }
+  }
+
+  override def get(id: BookId): Future[Option[BookData]] = {
+    Future.successful {
+      logger.trace(s"get: id = $id")
+      bookList.find(book => book.id == id)
+    }
+  }
+
+  def create(data: BookData): Future[BookId] = {
+    Future.successful {
+      logger.trace(s"create: data = $data")
+      data.id
+    }
+  }
+
+}
diff --git a/app/v1/book/BookResourceHandler.scala b/app/v1/book/BookResourceHandler.scala
new file mode 100644
index 0000000..45abcdc
--- /dev/null
+++ b/app/v1/book/BookResourceHandler.scala
@@ -0,0 +1,64 @@
+package v1.book
+
+import javax.inject.{Inject, Provider}
+
+import scala.concurrent.{ExecutionContext, Future}
+import play.api.libs.json._
+
+/**
+  * DTO for displaying book information.
+  */
+case class BookResource(id: String, link: String, title: String, body: String)
+
+object BookResource {
+
+  /**
+    * Mapping to write a BookResource out as a JSON value.
+    */
+  implicit val implicitWrites = new Writes[BookResource] {
+    def writes(book: BookResource): JsValue = {
+      Json.obj(
+        "id" -> book.id,
+        "link" -> book.link,
+        "title" -> book.title,
+        "body" -> book.body
+      )
+    }
+  }
+}
+
+/**
+  * Controls access to the backend data, returning [[BookResource]]
+  */
+class BookResourceHandler @Inject()(
+                                     routerProvider: Provider[BookRouter],
+                                     bookRepository: BookRepository)(implicit ec: ExecutionContext) {
+
+  def create(bookInput: BookFormInput): Future[BookResource] = {
+    val data = BookData(BookId("999"), bookInput.title, bookInput.body)
+    // We don't actually create the book, so return what we have
+    bookRepository.create(data).map { id =>
+      createBookResource(data)
+    }
+  }
+
+  def lookup(id: String): Future[Option[BookResource]] = {
+    val bookFuture = bookRepository.get(BookId(id))
+    bookFuture.map { maybeBookData =>
+      maybeBookData.map { bookData =>
+        createBookResource(bookData)
+      }
+    }
+  }
+
+  def find: Future[Iterable[BookResource]] = {
+    bookRepository.list().map { bookDataList =>
+      bookDataList.map(bookData => createBookResource(bookData))
+    }
+  }
+
+  private def createBookResource(p: BookData): BookResource = {
+    BookResource(p.id.toString, routerProvider.get.link(p.id), p.title, p.body)
+  }
+
+}
diff --git a/app/v1/book/BookRouter.scala b/app/v1/book/BookRouter.scala
new file mode 100644
index 0000000..dd5ae9a
--- /dev/null
+++ b/app/v1/book/BookRouter.scala
@@ -0,0 +1,32 @@
+package v1.book
+
+import javax.inject.Inject
+
+import play.api.routing.Router.Routes
+import play.api.routing.SimpleRouter
+import play.api.routing.sird._
+
+/**
+  * Routes and URLs to the BookResource controller.
+  */
+class BookRouter @Inject()(controller: BookController) extends SimpleRouter {
+  val prefix = "/v1/books"
+
+  def link(id: BookId): String = {
+    import com.netaporter.uri.dsl._
+    val url = prefix / id.toString
+    url.toString()
+  }
+
+  override def routes: Routes = {
+    case GET(p"/") =>
+      controller.index
+
+    case POST(p"/") =>
+      controller.process
+
+    case GET(p"/$id") =>
+      controller.show(id)
+  }
+
+}
diff --git a/app/v1/book/package.scala b/app/v1/book/package.scala
new file mode 100644
index 0000000..20457cc
--- /dev/null
+++ b/app/v1/book/package.scala
@@ -0,0 +1,16 @@
+package v1
+
+import play.api.i18n.Messages
+
+/**
+  * Package object for book.  This is a good place to put implicit conversions.
+  */
+package object book {
+
+  /**
+    * Converts between BookRequest and Messages automatically.
+    */
+  implicit def requestToMessages[A](implicit r: BookRequest[A]): Messages = {
+    r.messages
+  }
+}
diff --git a/app/v1/post/PostAction.scala b/app/v1/post/PostAction.scala
deleted file mode 100644
index 6f0fdec..0000000
--- a/app/v1/post/PostAction.scala
+++ /dev/null
@@ -1,54 +0,0 @@
-package v1.post
-
-import javax.inject.Inject
-
-import play.api.http.HttpVerbs
-import play.api.i18n.{Messages, MessagesApi}
-import play.api.mvc._
-
-import scala.concurrent.{ExecutionContext, Future}
-
-/**
-  * A wrapped request for post resources.
-  *
-  * This is commonly used to hold request-specific information like
-  * security credentials, and useful shortcut methods.
-  */
-class PostRequest[A](request: Request[A], val messages: Messages)
-    extends WrappedRequest(request)
-
-/**
-  * The default action for the Post resource.
-  *
-  * This is the place to put logging, metrics, to augment
-  * the request with contextual data, and manipulate the
-  * result.
-  */
-class PostAction @Inject()(messagesApi: MessagesApi)(
-    implicit ec: ExecutionContext)
-    extends ActionBuilder[PostRequest]
-    with HttpVerbs {
-
-  type PostRequestBlock[A] = PostRequest[A] => Future[Result]
-
-  private val logger = org.slf4j.LoggerFactory.getLogger(this.getClass)
-
-  override def invokeBlock[A](request: Request[A],
-                              block: PostRequestBlock[A]): Future[Result] = {
-    if (logger.isTraceEnabled()) {
-      logger.trace(s"invokeBlock: request = $request")
-    }
-
-    val messages = messagesApi.preferred(request)
-    val future = block(new PostRequest(request, messages))
-
-    future.map { result =>
-      request.method match {
-        case GET | HEAD =>
-          result.withHeaders("Cache-Control" -> s"max-age: 100")
-        case other =>
-          result
-      }
-    }
-  }
-}
diff --git a/app/v1/post/PostController.scala b/app/v1/post/PostController.scala
deleted file mode 100644
index 19e7024..0000000
--- a/app/v1/post/PostController.scala
+++ /dev/null
@@ -1,68 +0,0 @@
-package v1.post
-
-import javax.inject.Inject
-
-import play.api.data.Form
-import play.api.libs.json.Json
-import play.api.mvc._
-
-import scala.concurrent.{ExecutionContext, Future}
-
-case class PostFormInput(title: String, body: String)
-
-/**
-  * Takes HTTP requests and produces JSON.
-  */
-class PostController @Inject()(
-    action: PostAction,
-    handler: PostResourceHandler)(implicit ec: ExecutionContext)
-    extends Controller {
-
-  private val form: Form[PostFormInput] = {
-    import play.api.data.Forms._
-
-    Form(
-      mapping(
-        "title" -> nonEmptyText,
-        "body" -> text
-      )(PostFormInput.apply)(PostFormInput.unapply)
-    )
-  }
-
-  def index: Action[AnyContent] = {
-    action.async { implicit request =>
-      handler.find.map { posts =>
-        Ok(Json.toJson(posts))
-      }
-    }
-  }
-
-  def process: Action[AnyContent] = {
-    action.async { implicit request =>
-      processJsonPost()
-    }
-  }
-
-  def show(id: String): Action[AnyContent] = {
-    action.async { implicit request =>
-      handler.lookup(id).map { post =>
-        Ok(Json.toJson(post))
-      }
-    }
-  }
-
-  private def processJsonPost[A]()(
-      implicit request: PostRequest[A]): Future[Result] = {
-    def failure(badForm: Form[PostFormInput]) = {
-      Future.successful(BadRequest(badForm.errorsAsJson))
-    }
-
-    def success(input: PostFormInput) = {
-      handler.create(input).map { post =>
-        Created(Json.toJson(post)).withHeaders(LOCATION -> post.link)
-      }
-    }
-
-    form.bindFromRequest().fold(failure, success)
-  }
-}
diff --git a/app/v1/post/PostRepository.scala b/app/v1/post/PostRepository.scala
deleted file mode 100644
index 8005dfe..0000000
--- a/app/v1/post/PostRepository.scala
+++ /dev/null
@@ -1,68 +0,0 @@
-package v1.post
-
-import javax.inject.{Inject, Singleton}
-
-import scala.concurrent.Future
-
-final case class PostData(id: PostId, title: String, body: String)
-
-class PostId private (val underlying: Int) extends AnyVal {
-  override def toString: String = underlying.toString
-}
-
-object PostId {
-  def apply(raw: String): PostId = {
-    require(raw != null)
-    new PostId(Integer.parseInt(raw))
-  }
-}
-
-/**
-  * A pure non-blocking interface for the PostRepository.
-  */
-trait PostRepository {
-  def create(data: PostData): Future[PostId]
-
-  def list(): Future[Iterable[PostData]]
-
-  def get(id: PostId): Future[Option[PostData]]
-}
-
-/**
-  * A trivial implementation for the Post Repository.
-  */
-@Singleton
-class PostRepositoryImpl @Inject() extends PostRepository {
-
-  private val logger = org.slf4j.LoggerFactory.getLogger(this.getClass)
-
-  private val postList = List(
-    PostData(PostId("1"), "title 1", "blog post 1"),
-    PostData(PostId("2"), "title 2", "blog post 2"),
-    PostData(PostId("3"), "title 3", "blog post 3"),
-    PostData(PostId("4"), "title 4", "blog post 4"),
-    PostData(PostId("5"), "title 5", "blog post 5")
-  )
-
-  override def list(): Future[Iterable[PostData]] = {
-    Future.successful {
-      logger.trace(s"list: ")
-      postList
-    }
-  }
-
-  override def get(id: PostId): Future[Option[PostData]] = {
-    Future.successful {
-      logger.trace(s"get: id = $id")
-      postList.find(post => post.id == id)
-    }
-  }
-
-  def create(data: PostData): Future[PostId] = {
-    Future.successful {
-      logger.trace(s"create: data = $data")
-      data.id
-    }
-  }
-
-}
diff --git a/app/v1/post/PostResourceHandler.scala b/app/v1/post/PostResourceHandler.scala
deleted file mode 100644
index 9f1224c..0000000
--- a/app/v1/post/PostResourceHandler.scala
+++ /dev/null
@@ -1,65 +0,0 @@
-package v1.post
-
-import javax.inject.{Inject, Provider}
-
-import scala.concurrent.{ExecutionContext, Future}
-
-import play.api.libs.json._
-
-/**
-  * DTO for displaying post information.
-  */
-case class PostResource(id: String, link: String, title: String, body: String)
-
-object PostResource {
-
-  /**
-    * Mapping to write a PostResource out as a JSON value.
-    */
-  implicit val implicitWrites = new Writes[PostResource] {
-    def writes(post: PostResource): JsValue = {
-      Json.obj(
-        "id" -> post.id,
-        "link" -> post.link,
-        "title" -> post.title,
-        "body" -> post.body
-      )
-    }
-  }
-}
-
-/**
-  * Controls access to the backend data, returning [[PostResource]]
-  */
-class PostResourceHandler @Inject()(
-    routerProvider: Provider[PostRouter],
-    postRepository: PostRepository)(implicit ec: ExecutionContext) {
-
-  def create(postInput: PostFormInput): Future[PostResource] = {
-    val data = PostData(PostId("999"), postInput.title, postInput.body)
-    // We don't actually create the post, so return what we have
-    postRepository.create(data).map { id =>
-      createPostResource(data)
-    }
-  }
-
-  def lookup(id: String): Future[Option[PostResource]] = {
-    val postFuture = postRepository.get(PostId(id))
-    postFuture.map { maybePostData =>
-      maybePostData.map { postData =>
-        createPostResource(postData)
-      }
-    }
-  }
-
-  def find: Future[Iterable[PostResource]] = {
-    postRepository.list().map { postDataList =>
-      postDataList.map(postData => createPostResource(postData))
-    }
-  }
-
-  private def createPostResource(p: PostData): PostResource = {
-    PostResource(p.id.toString, routerProvider.get.link(p.id), p.title, p.body)
-  }
-
-}
diff --git a/app/v1/post/PostRouter.scala b/app/v1/post/PostRouter.scala
deleted file mode 100644
index 809f34e..0000000
--- a/app/v1/post/PostRouter.scala
+++ /dev/null
@@ -1,32 +0,0 @@
-package v1.post
-
-import javax.inject.Inject
-
-import play.api.routing.Router.Routes
-import play.api.routing.SimpleRouter
-import play.api.routing.sird._
-
-/**
-  * Routes and URLs to the PostResource controller.
-  */
-class PostRouter @Inject()(controller: PostController) extends SimpleRouter {
-  val prefix = "/v1/posts"
-
-  def link(id: PostId): String = {
-    import com.netaporter.uri.dsl._
-    val url = prefix / id.toString
-    url.toString()
-  }
-
-  override def routes: Routes = {
-    case GET(p"/") =>
-      controller.index
-
-    case POST(p"/") =>
-      controller.process
-
-    case GET(p"/$id") =>
-      controller.show(id)
-  }
-
-}
diff --git a/app/v1/post/package.scala b/app/v1/post/package.scala
deleted file mode 100644
index 7903bbe..0000000
--- a/app/v1/post/package.scala
+++ /dev/null
@@ -1,16 +0,0 @@
-package v1
-
-import play.api.i18n.Messages
-
-/**
-  * Package object for post.  This is a good place to put implicit conversions.
-  */
-package object post {
-
-  /**
-    * Converts between PostRequest and Messages automatically.
-    */
-  implicit def requestToMessages[A](implicit r: PostRequest[A]): Messages = {
-    r.messages
-  }
-}
diff --git a/app/views/index.scala.html b/app/views/index.scala.html
index e070978..fcea89b 100644
--- a/app/views/index.scala.html
+++ b/app/views/index.scala.html
@@ -15,7 +15,7 @@
     </p>
 
     <ul>
-      <li><a href="/v1/posts">/v1/posts</a></li>
+      <li><a href="/v1/books">/v1/books</a></li>
     </ul>
   </body>
 </html>
diff --git a/conf/routes b/conf/routes
index 91006f3..bfdd822 100644
--- a/conf/routes
+++ b/conf/routes
@@ -1,6 +1,6 @@
 GET        /                       controllers.HomeController.index
 
-->         /v1/posts               v1.post.PostRouter
+->         /v1/books               v1.book.BookRouter
 
 # Map static resources from the /public folder to the /assets URL path
 GET        /assets/*file        controllers.Assets.at(path="/public", file)
diff --git a/docs/build.sbt b/docs/build.sbt
deleted file mode 100644
index c84640b..0000000
--- a/docs/build.sbt
+++ /dev/null
@@ -1,9 +0,0 @@
-// You will need private bintray credentials to publish this with Lightbend theme
-// credentials += Credentials("Bintray", "dl.bintray.com", "<user>", "<bintray API key>")
-// resolvers += "bintray-typesafe-internal-maven-releases" at "https://dl.bintray.com/typesafe/internal-maven-releases/"
-// paradoxTheme := Some("com.lightbend.paradox" % "paradox-theme-lightbend" % "0.2.3")
-
-// Uses the out of the box generic theme.
-paradoxTheme := Some(builtinParadoxTheme("generic"))
-
-scalaVersion := "2.11.11"
diff --git a/docs/src/main/paradox/appendix.md b/docs/src/main/paradox/appendix.md
deleted file mode 100644
index a81ef37..0000000
--- a/docs/src/main/paradox/appendix.md
+++ /dev/null
@@ -1,84 +0,0 @@
-
-# Appendix
-
-This appendix covers how to download, run, use and load test Play.
-
-## Requirements
-
-You will need a JDK 1.8 that is more recent than b20.  You can download the JDK from [here](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html).
-
-You will need to have git installed.
-
-## Downloading
-
-You can download the example project from Github:
-
-```
-git clone https://github.com/playframework/play-rest-api.git
-```
-
-## Running
-
-You need to download and install sbt for this application to run.  You can do that by going to the [sbt download page](http://www.scala-sbt.org/download.html) and following the instructions for your platform.
-
-Once you have sbt installed, the following at the command prompt will download any required library dependencies, and start up Play in development mode:
-
-```
-sbt run
-```
-
-Play will start up on the HTTP port at http://localhost:9000/.   You don't need to reploy or reload anything -- changing any source code while the server is running will automatically recompile and hot-reload the application on the next HTTP request.  You can read more about using Play [here](https://www.playframework.com/documentation/2.5.x/PlayConsole).
-
-## Usage
-
-If you call the same URL from the command line, you’ll see JSON. Using [httpie](https://httpie.org/), we can execute the command:
-
-```
-http --verbose http://localhost:9000/v1/posts
-```
-
-and get back:
-
-```
-GET /v1/posts HTTP/1.1
-```
-
-Likewise, you can also send a POST directly as JSON:
-
-```
-http --verbose POST http://localhost:9000/v1/posts title="hello" body="world"
-```
-
-and get:
-
-```
-POST /v1/posts HTTP/1.1
-```
-
-## Load Testing
-
-The best way to see what Play can do is to run a load test.  We've included Gatling in this test project for integrated load testing.
-
-Start Play in production mode, by [staging the application](https://www.playframework.com/documentation/2.5.x/Deploying) and running the play scripts:
-
-```
-sbt stage
-cd target/universal/stage
-bin/play-rest-api -Dplay.crypto.secret=testing
-```
-
-Then you'll start the Gatling load test up (it's already integrated into the project):
-
-```
-sbt gatling:test
-```
-
-For best results, start the gatling load test up on another machine so you do not have contending resources.  You can edit the [Gatling simulation](http://gatling.io/docs/2.2.2/general/simulation_structure.html#simulation-structure), and change the numbers as appropriate.
-
-Once the test completes, you'll see an HTML file containing the load test chart:
-
-```
- ./rest-api/target/gatling/gatlingspec-1472579540405/index.html
-```
-
-That will contain your load test results.
diff --git a/docs/src/main/paradox/index.md b/docs/src/main/paradox/index.md
deleted file mode 100644
index f406497..0000000
--- a/docs/src/main/paradox/index.md
+++ /dev/null
@@ -1,70 +0,0 @@
-# Making a REST API with Play
-
-This is a multi-part guide to walk you through how to make a RESTful API with JSON using [Play 2.5](https://playframework.com).
-
-We’ll demonstrate with a “best practices” REST API.  You can get source code for this guide two ways:
-
-* Download a pre-packaged bundle with this link [https://example.lightbend.com/v1/download/play-scala-rest-api-example](https://example.lightbend.com/v1/download/play-scala-rest-api-example)
-
-    * Linux/Mac:
-```bash
-unzip play-scala-rest-api-example.zip
-cd play-scala-rest-api-example
-./sbt
-```
-    * Windows:
-
-        1. Unzip the download
-        2. From a command line `cd` into the directory where you expanded the downloaded `zip` file and run:
-```
-sbt.bat
-```
-
-* [From Github](https://github.com/playframework/play-scala-rest-api-example/tree/2.5.x):
-```
-git clone https://github.com/playframework/play-scala-rest-api-example.git
-git checkout 2.5.x
-```
-
-This example is in Scala, but Play also has a [Java API](https://www.playframework.com/documentation/2.5.x/JavaHome) which looks and acts just like the [Scala API](https://www.playframework.com/documentation/2.5.x/ScalaHome), and has a corresponding [play-java-rest-api-example](https://github.com/playframework/play-java-rest-api-example) project.  For instructions on running and using the project, please see the [[appendix]].  This project also comes with an integrated [Gatling](http://gatling.io/) load test -- again, instructions are in the appendix.
-
-Note that there’s more involved in a REST API -- monitoring, representation, and managing access to back end resources -- that we'll cover in subsequent posts.  But first, let's address why Play is so effective as a REST API.
-
-## When to use Play
-
-Play makes a good REST API implementation because Play does the right thing out of the box.  Play makes simple things easy, makes hard things possible, and encourages code that scales because it works in sympathy with the JVM and the underlying hardware. But "safe and does the right thing" is the boring answer.
-
-The fun answer is that [Play is **fast**](https://www.lightbend.com/blog/why-is-play-framework-so-fast).
-
-In fact, Play is so fast that you have to turn off machines so that the rest of your architecture can keep up.  The Hootsuite team was able to **reduce the number of servers by 80%** by [switching to Play](https://www.lightbend.com/resources/case-studies-and-stories/how-hootsuite-modernized-its-url-shortener).  if you deploy Play with the same infrastructure that you were using for other web frameworks, you are effectively staging a denial of service attack against your own database.
-
-Play is fast because Play is **built on reactive bedrock**.  Play starts from a reactive core, and builds on reactive principles all the way from the ground.  Play breaks network packets into a stream of small chunks of bytes.  It keeps a small pool of work stealing threads, mapped to the number of cores in the machine, and keeps those threads fed with those chunks.  Play exposes those byte chunks to the application for body parsing, Server Sent Events and WebSockets through [Akka Streams](http://doc.akka.io/docs/akka/2.4/scala/stream/stream-introduction.html) -- the Reactive Streams implementation designed by the people who invented [Reactive Streams](http://www.reactive-streams.org/) and wrote the [Reactive Manifesto](http://www.reactivemanifesto.org/).
-
-Linkedin uses Play throughout its infrastructure. It wins on all [four quadrants of scalability](http://www.slideshare.net/brikis98/the-play-framework-at-linkedin/128-Outline1_Getting_started_with_Play2) ([video](https://youtu.be/8z3h4Uv9YbE)).  Play's average "request per second" comes in around [tens of k on a basic quad core w/o any intentional tuning](https://twitter.com/kevinbowling1/status/764188720140398592) -- and it only gets better.
-
-Play provides an easy to use MVC paradigm, including hot-reloading without any JVM bytecode magic or container overhead.  Startup time for a developer on Play was **reduced by roughly 7 times** for [Walmart Canada](https://www.lightbend.com/resources/case-studies-and-stories/walmart-boosts-conversions-by-20-with-lightbend-reactive-platform), and using Play **reduced development times by 2x to 3x**.
-
-Play combines this with a **reactive programming API** that lets you write async, non-blocking code in a straightforward fashion without worrying about complex and confusing "callback hell."  In both Java or Scala, Play works on the same principle: leverage the asynchronous computation API that the language provides to you.  In Play, you work with [`java.util.concurrent.CompletionStage`](https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/changes8.html) or [`scala.concurrent.Future`](http://docs.scala-lang.org/overviews/core/futures.html) API directly, and Play passes that asynchronous computation back through the framework.
-
-Finally, Play is modular and extensible.  Play works with multiple runtime and compile time dependency injection frameworks like [Guice](https://www.playframework.com/documentation/2.5.x/ScalaDependencyInjection), [Macwire](https://di-in-scala.github.io/), [Dagger](https://github.com/esfand-r/play-java-dagger-dependency-injection#master), and leverages DI principles to integrate authentication and authorization frameworks built on top of Play.
-
-## Community
-
-To learn more about Play, check out the [Play tutorials](https://playframework.com/documentation/2.5.x/Tutorials) and see more examples and blog posts about Play, including streaming [Server Side Events](https://github.com/playframework/play-streaming-scala) and first class [WebSocket support](https://github.com/playframework/play-websocket-scala).
-
-To get more involved and if you have questions, join the [mailing list](https://groups.google.com/forum/#!forum/play-framework) at  and follow [PlayFramework on Twitter](https://twitter.com/playframework).
-
-## Microservices vs REST APIs
-
-One thing to note here is that although this guide covers how to make a REST API in Play, it only covers Play itself and deploying Play.  Building a REST API in Play does not automatically make it a "microservice" because it does not cover larger scale concerns about microservices such as ensuring resiliency, consistency, or monitoring.
-
-For full scale microservices, you want [Lagom](http://www.lagomframework.com/), which builds on top of Play -- a microservices framework for dealing with the ["data on the outside"](https://blog.acolyer.org/2016/09/13/data-on-the-outside-versus-data-on-the-inside/) problem, set up with persistence and service APIs that ensure that the service always stays up and responsive even in the face of chaos monkeys and network partitions.
-
-With that caveat, let's start working with Play!
-
-@@@index
-
-* [Basics](part-1/index.md)
-* [Appendix](appendix.md)
-
-@@@
diff --git a/docs/src/main/paradox/part-1/index.md b/docs/src/main/paradox/part-1/index.md
deleted file mode 100644
index 1c2055c..0000000
--- a/docs/src/main/paradox/part-1/index.md
+++ /dev/null
@@ -1,424 +0,0 @@
-# Basics
-
-This guide will walk you through how to make a REST API with JSON using [Play 2.5](https://playframework.com).
-
-To see the associated Github project, please go to [https://github.com/playframework/play-rest-api](https://github.com/playframework/play-rest-api) or clone the project:
-
-```
-git clone https://github.com/playframework/play-rest-api.git
-```
-
-We're going to be showing an already working Play project with most of the code available under the "app/v1" directory.  There will be several different versions of the same project as this series expands, so you can compare different versions of the project against each other.
-
-To run Play on your own local computer, please see the instructions in the [appendix](../appendix.md). 
-
-## Introduction
-
-We'll start off with a REST API that displays information for blog posts.  Users should be able to write a title and a body of a blog post and create new blog posts, edit existing blog posts, and delete new blog posts.
-
-## Modelling a Post Resource
-
-The way to do this in REST is to model the represented state as a resource.  A blog post resource will have a unique id, a URL hyperlink that indicates the canonical location of the resource, the title of the blog post, and the body of the blog post.
-
-This resource is represented as a single case class in the Play application [here](https://github.com/playframework/play-rest-api/blob/master/app/v1/post/PostResourceHandler.scala#L13):
-
-```scala
-case class PostResource(id: String, link: String,
-                        title: String, body: String)
-```
-
-This resource is mapped to and from JSON on the front end using Play, and is mapped to and from a persistent datastore on the backend using a handler.  
-
-Play handles HTTP routing and representation for the REST API and makes it easy to write a non-blocking, asynchronous API that is an order of magnitude more efficient than other web application frameworks.
-
-## Routing Post Requests
-
-Play has two complimentary routing mechanisms.  In the conf directory, there's a file called "routes" which contains entries for the HTTP method and a relative URL path, and points it at an action in a controller.
-
-```
-GET    /               controllers.HomeController.index()
-```
-
-This is useful for situations where a front end service is rendering HTML.  However, Play also contains a more powerful routing DSL that we will use for the REST API.
-
-For every HTTP request starting with `/v1/posts`, Play routes it to a dedicated `PostRouter` class to handle the Posts resource, through the [`conf/routes`](https://github.com/playframework/play-rest-api/blob/master/conf/routes) file:
-
-```
-->     /v1/posts               v1.post.PostRouter
-```
-
-The `PostRouter` examines the URL and extracts data to pass along to the controller [here](https://github.com/playframework/play-rest-api/blob/master/app/v1/post/PostRouter.scala):
-
-```scala
-package v1.post
-import javax.inject.Inject
-
-import play.api.mvc._
-import play.api.routing.Router.Routes
-import play.api.routing.SimpleRouter
-import play.api.routing.sird._
-
-class PostRouter @Inject()(controller: PostController)
-  extends SimpleRouter
-{
-  override def routes: Routes = {
-    case GET(p"/") =>
-     controller.index
-      
-    case POST(p"/") =>
-      controller.process
-
-    case GET(p"/$id") =>
-      controller.show(id)
-  }
-}
-```
-
-Play’s [routing DSL](https://www.playframework.com/documentation/2.5.x/ScalaSirdRouter) (technically "String Interpolation Routing DSL", aka SIRD) shows how data can be extracted from the URL concisely and cleanly.  SIRD is based around HTTP methods and a string interpolated extractor object – this means that when we type the string “/$id” and prefix it with “p”, then the path parameter id can be extracted and used in the block. Naturally, there are also operators to extract queries, regular expressions, and even add custom extractors.  If you have a URL as follows:
-
-```
-/posts/?sort=ascending&count=5
-```
-
-then you can extract the "sort" and "count" parameters in a single line:
-
-```scala
-GET("/" ? q_?"sort=$sort" & q_?”count=${ int(count) }")
-```
-
-SIRD is especially useful in a REST API where there can be many possible query parameters. Cake Solutions covers SIRD in more depth in a [fantastic blog post](http://www.cakesolutions.net/teamblogs/all-you-need-to-know-about-plays-routing-dsl).
-
-## Using a Controller
-
-The PostRouter has a PostController injected into it through standard [JSR-330 dependency injection](https://github.com/google/guice/wiki/JSR330) [here](https://github.com/playframework/play-rest-api/blob/master/app/v1/post/PostRouter.scala#L12):
-
-```scala
-class PostRouter @Inject()(controller: PostController)
-  extends SimpleRouter
-```
-
-Before heading into the PostController, let's discuss how controllers work in Play.
-
-A controller [handles the work of processing](https://www.playframework.com/documentation/2.5.x/ScalaActions)  the HTTP request into an HTTP response in the context of an Action: it's where page rendering and HTML form processing happen.  A controller extends [`play.api.mvc.Controller`](https://playframework.com/documentation/2.5.x/api/scala/index.html#play.api.mvc.Controller), which contains a number of utility methods and constants for working with HTTP.  In particular, a Controller contains Result objects such as Ok and Redirect, and HeaderNames like ACCEPT.
-
-The methods in a controller consist of a method returning an [Action](https://playframework.com/documentation/2.5.x/api/scala/index.html#play.api.mvc.Action).  The Action provides the "engine" to Play.
-
-Using the action, the controller passes in a block of code that takes a [`Request`](https://playframework.com/documentation/2.5.x/api/scala/index.html#play.api.mvc.Request) passed in as implicit – this means that any in-scope method that takes an implicit request as a parameter will use this request automatically.  Then, the block must return either a [`Result`](https://playframework.com/documentation/2.5.x/api/scala/index.html#play.api.mvc.Result), or a [`Future[Result]`](http://www.scala-lang.org/api/current/index.html#scala.concurrent.Future), depending on whether or not the action was called as `action { ... }` or [`action.async { ... }`](https://www.playframework.com/documentation/2.5.x/ScalaAsync#How-to-create-a-Future[Result]). 
- 
-### Handling GET Requests
-
-
-Here's a simple example of a Controller:
- 
-```scala
-import javax.inject.Inject
-import play.api.mvc._
-
-import scala.concurrent._
-
-class MyController extends Controller {
-
-  def index1: Action[AnyContent] = {
-    Action { implicit request =>
-      val r: Result = Ok("hello world")
-      r
-    }
-  }
-
-  def asyncIndex: Action[AnyContent] = {
-    Action.async { implicit request =>
-      val r: Future[Result] = Future.successful(Ok("hello world"))
-      r
-    }
-  }
-}
-```
-
-In this example, `index1` and `asyncIndex` have exactly the same behavior.  Internally, it makes no difference whether we call `Result` or `Future[Result]` -- Play is non-blocking all the way through. 
-
-However, if you're already working with `Future`, async makes it easier to pass that `Future` around. You can read more about this in the [handling asynchronous results](https://www.playframework.com/documentation/2.5.x/ScalaAsync) section of the Play documentation.
-
-The PostController methods dealing with GET requests is [here](https://github.com/playframework/play-rest-api/blob/master/app/v1/post/PostController.scala):
-
-```scala
-class PostController @Inject()(action: PostAction,
-                              handler: PostResourceHandler)
-                             (implicit ec: ExecutionContext)
- extends Controller {
-
- def index: Action[AnyContent] = {
-   action.async { implicit request =>
-     handler.find.map { posts =>
-       Ok(Json.toJson(posts))
-     }
-   }
- }
-
- def show(id: String): Action[AnyContent] = {
-   action.async { implicit request =>
-     handler.lookup(id).map { post =>
-       Ok(Json.toJson(post))
-     }
-   }
- }
-
-}
-```
-
-Let's take `show` as an example.  Here, the action defines a workflow for a request that maps to a single resource, i.e. `GET /v1/posts/123`.  
-
-```scala
-def show(id: String): Action[AnyContent] = {
-  action.async { implicit request =>
-    handler.lookup(id).map { post =>
-      Ok(Json.toJson(post))
-    }
-  }
-}
-```
-
-The id is passed in as a String, and the handler looks up and returns a `PostResource`.  The `Ok()` sends back a `Result` with a status code of "200 OK", containing a response body consisting of the `PostResource` serialized as JSON.
-
-### Processing Form Input
-
-Handling a POST request is also easy and is done through the `process` method:
-
-```scala
-class PostController @Inject()(action: PostAction,
-                              handler: PostResourceHandler)
-                             (implicit ec: ExecutionContext)
-  extends Controller {
-
-  private val form: Form[PostFormInput] = {
-    import play.api.data.Forms._
-
-    Form(
-      mapping(
-        "title" -> nonEmptyText,
-        "body" -> text
-      )(PostFormInput.apply)(PostFormInput.unapply)
-    )
-  }
-
-  def process: Action[AnyContent] = {
-    action.async { implicit request =>
-      processJsonPost()
-    }
-  }
-
-  private def processJsonPost[A]()(implicit request: PostRequest[A]):  Future[Result] = {
-    def failure(badForm: Form[PostFormInput]) = {
-      Future.successful(BadRequest(badForm.errorsAsJson))
-    }
-
-    def success(input: PostFormInput) = {
-      handler.create(input).map { post =>
-        Created(Json.toJson(post))
-          .withHeaders(LOCATION -> post.link)
-      }
-    }
-
-    form.bindFromRequest().fold(failure, success)
-  }
-}
-```
-
-Here, the `process` action is an action wrapper, and `processJsonPost` does most of the work.  In `processJsonPost`, we get to the [form processing](https://www.playframework.com/documentation/2.5.x/ScalaForms) part of the code.  
-
-Here, `form.bindFromRequest()` will map input from the HTTP request to a [`play.api.data.Form`](https://www.playframework.com/documentation/2.5.x/api/scala/index.html#play.api.data.Form), and handles form validation and error reporting.  
-
-If the `PostFormInput` passes validation, it's passed to the resource handler, using the `success` method.  If the form processing fails, then the `failure` method is called and the `FormError` is returned in JSON format.
-
-```scala
-private val form: Form[PostFormInput] = {
-  import play.api.data.Forms._
-
-  Form(
-    mapping(
-      "title" -> nonEmptyText,
-      "body" -> text
-    )(PostFormInput.apply)(PostFormInput.unapply)
-  )
-}
-```
-
-The form binds to the HTTP request using the names in the mapping -- "title" and "body" to the `PostFormInput` case class [here](https://github.com/playframework/play-rest-api/blob/master/app/v1/post/PostController.scala#L11).
-
-```scala
-case class PostFormInput(title: String, body: String)
-```
-
-That's all you need to do to handle a basic web application!  As with most things, there are more details that need to be handled.  That's where creating custom Actions comes in.
-
-## Using Actions
-
-We saw in the `PostController` that each method is connected to an Action through the "action.async" method [here](https://github.com/playframework/play-rest-api/blob/master/app/v1/post/PostController.scala#L32):
-
-```scala
-  def index: Action[AnyContent] = {
-    action.async { implicit request =>
-      handler.find.map { posts =>
-        Ok(Json.toJson(posts))
-      }
-    }
-  }
-```
-
-The action.async takes a function, and comes from the class parameter "action", which we can see is of type `PostAction` [here](https://github.com/playframework/play-rest-api/blob/master/app/v1/post/PostController.scala#L16):
-
-```scala
-class PostController @Inject()(action: PostAction [...])
-```
-
-`PostAction` is an ActionBuilder.  It is involved in each action in the controller -- it mediates the paperwork involved with processing a request into a response, adding context to the request and enriching the response with headers and cookies.  ActionBuilders are essential for handling authentication, authorization and monitoring functionality.
-
-ActionBuilders work through a process called [action composition](https://www.playframework.com/documentation/2.5.x/ScalaActionsComposition).  The ActionBuilder class has a method called `invokeBlock` that takes in a `Request` and a function (also known as a block, lambda or closure) that accepts a `Request` of a given type, and produces a `Future[Result]`.
-
-So, if you want to work with an `Action` that has a "FooRequest" that has a Foo attached, it's easy: 
-
-```scala
-class FooRequest[A](request: Request[A], val foo: Foo) extends WrappedRequest(request)
-
-class FooAction extends ActionBuilder[FooRequest] {
-  type FooRequestBlock[A] = FooRequest[A] => Future[Result]
-
-  override def invokeBlock[A](request: Request[A], block: FooRequestBlock[A]) = {
-    block(new FooRequest[A](request, new Foo))
-  }
-}
-```
-
-You create an `ActionBuilder[FooRequest]`, override `invokeBlock`, and then call the function with an instance of `FooRequest`.  
-
-Then, when you call `fooAction`, the request type is `FooRequest`:
-
-```scala
-fooAction { request: FooRequest => 
-  Ok(request.foo.toString)
-}
-```
-
-And `request.foo` will be added automatically.
-
-You can keep composing action builders inside each other, so you don't have to layer all the functionality in one single ActionBuilder, or you can create a custom `ActionBuilder` for each package you work with, according to your taste.  For the purposes of this blog post, we'll keep everything together in a single class.
-
-You can see PostAction [here](https://github.com/playframework/play-rest-api/blob/master/app/v1/post/PostAction.scala):
-
-```scala
-class PostRequest[A](request: Request[A], 
-                     val messages: Messages)
-  extends WrappedRequest(request)
-
-class PostAction @Inject()(messagesApi: MessagesApi)
-                          (implicit ec: ExecutionContext)
-  extends ActionBuilder[PostRequest] with HttpVerbs {
-
-  type PostRequestBlock[A] = PostRequest[A] => Future[Result]
-
-  private val logger = org.slf4j.LoggerFactory.getLogger(this.getClass)
-
-  override def invokeBlock[A](request: Request[A], 
-                              block: PostRequestBlock[A]) = {
-    if (logger.isTraceEnabled()) {
-      logger.trace(s"invokeBlock: request = $request")
-    }
-
-    val messages = messagesApi.preferred(request)
-    val future = block(new PostRequest(request, messages))
-
-    future.map { result =>
-      request.method match {
-        case GET | HEAD =>
-          result.withHeaders("Cache-Control" -> s"max-age: 100")
-        case other =>
-          result
-      }
-    }
-  }
-}
-```
-
-`PostAction` does a couple of different things here.  The first thing it does is to log the request as it comes in.  Next, it pulls out the localized `Messages` for the request, and adds that to a `PostRequest` , and runs the function, returning a `Future[Result]`.
-
-When the future completes, we map the result so we can replace it with a slightly different result.  We compare the result's method against `HttpVerbs`, and if it's a GET or HEAD, we append a Cache-Control header with a max-age directive.  We need an `ExecutionContext` for `future.map` operations, so we pass in the default execution context implicitly at the top of the class.
-
-Now that we have a `PostRequest`, we can call "request.messages" explicitly from any action in the controller, for free, and we can append information to the result after the user action has been completed.
-
-## Converting resources with PostResourceHandler
-
-The `PostResourceHandler` is responsible for converting backend data from a repository into a `PostResource`. We won't go into detail on the `PostRepository` details for now, only that it returns data in an backend-centric state.
-
-A REST resource has information that a backend repository does not -- it knows about the operations available on the resource, and contains URI information that a single backend may not have.  As such, we want to be able to change the representation that we use internally without changing the resource that we expose publicly.  
-
-You can see the `PostResourceHandler` [here](https://github.com/playframework/play-rest-api/blob/master/app/v1/post/PostResourceHandler.scala):
-
-```scala
-class PostResourceHandler @Inject()(routerProvider: Provider[PostRouter],
-                                   postRepository: PostRepository)
-                                  (implicit ec: ExecutionContext)
-{
-
- def create(postInput: PostFormInput): Future[PostResource] = {
-   val data = PostData(PostId("999"), postInput.title, postInput.body)
-   postRepository.create(data).map { id =>
-     createPostResource(data)
-   }
- }
-
- def lookup(id: String): Future[Option[PostResource]] = {
-   val postFuture = postRepository.get(PostId(id))
-   postFuture.map { maybePostData =>
-     maybePostData.map { postData =>
-       createPostResource(postData)
-     }
-   }
- }
-
- def find: Future[Iterable[PostResource]] = {
-   postRepository.list().map { postDataList =>
-     postDataList.map(postData => createPostResource(postData))
-   }
- }
-
- private def createPostResource(p: PostData): PostResource = {
-   PostResource(p.id.toString, routerProvider.get.link(p.id), p.title, p.body)
- }
-
-}
-```
-
-Here, it's a straight conversion in `createPostResource`, with the only hook being that the router provides the resource's URL, since it's something that `PostData` doesn't have itself.
-
-## Rendering Content as JSON
-
-Play handles the work of converting a `PostResource` through [Play JSON](https://www.playframework.com/documentation/2.5.x/ScalaJson). Play JSON provides a DSL that looks up the conversion for the `PostResource` singleton object, so you don't need to declare it at the use point.
-
-You can see the `PostResource` object [here](https://github.com/playframework/play-rest-api/blob/master/app/v1/post/PostResourceHandler.scala#L18):
-
-```scala
-object PostResource {
-  implicit val implicitWrites = new Writes[PostResource] {
-    def writes(post: PostResource): JsValue = {
-      Json.obj(
-        "id" -> post.id,
-        "link" -> post.link,
-        "title" -> post.title,
-        "body" -> post.body)
-    }
-  }
-}
-```
-
-Once the implicit is defined in the companion object, then it will be looked up automatically when handed an instance of the class.  This means that when the controller converts to JSON, the conversion will just work, without any additional imports or setup.  
-
-```scala
-val json: JsValue = Json.toJson(post)
-```
-
-Play JSON also has options to incrementally parse and generate JSON for continuously streaming JSON responses.
-
-## Summary
-
-We've shown how to easy it is to put together a basic REST API in Play.  Using this code, we can put together backend data, convert it to JSON and transfer it over HTTP with a minimum of fuss.
-
-In the next guide, we'll discuss content representation and provide an HTML interface that exists alongside the JSON API.
diff --git a/gatling/simulation/GatlingSpec.scala b/gatling/simulation/GatlingSpec.scala
index c55f948..5402747 100644
--- a/gatling/simulation/GatlingSpec.scala
+++ b/gatling/simulation/GatlingSpec.scala
@@ -11,7 +11,7 @@ class GatlingSpec extends Simulation {
 
   // change this to another machine, make sure you have Play running in producion mode
   // i.e. sbt stage / sbt dist and running the script
-  val httpConf = http.baseURL("http://localhost:9000/v1/posts")
+  val httpConf = http.baseURL("http://localhost:9000/v1/books")
 
   val readClients = scenario("Clients").exec(Index.refreshManyTimes)
 
